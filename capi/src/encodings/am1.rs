// Auto-generated by codegen, do not edit manually

use std::ffi::{c_int, c_void};

use rustsat::{
    encodings::am1::{Bitwise, Encode, Ladder, Pairwise},
    types::Lit,
};

use super::{Bimander, CClauseCollector, ClauseCollector, Commander, MaybeError, VarManager};

/// Creates a new [`Pairwise`] at-most-one encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn pairwise_new() -> *mut Pairwise {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`Pairwise`]
///
/// # Safety
///
/// `pairwise` must be a return value of [`pairwise_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn pairwise_drop(pairwise: *mut Pairwise) {
    drop(Box::from_raw(pairwise));
}

/// Adds a new input literal to a [`Pairwise`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///     [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `pairwise` must be a return value of [`pairwise_new`] that [`pairwise_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn pairwise_add(pairwise: *mut Pairwise, lit: c_int) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*pairwise).extend([lit]);
    MaybeError::Ok
}

/// Builds the [`Pairwise`] at-most-one encoding
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Safety
///
/// `pairwise` must be a return value of [`pairwise_new`] that [`pairwise_drop`] has not yet been called on.
#[allow(clippy::missing_panics_doc)]
#[no_mangle]
pub unsafe extern "C" fn pairwise_encode(
    pairwise: *mut Pairwise,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*pairwise)
        .encode(&mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Creates a new [`Ladder`] at-most-one encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn ladder_new() -> *mut Ladder {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`Ladder`]
///
/// # Safety
///
/// `ladder` must be a return value of [`ladder_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn ladder_drop(ladder: *mut Ladder) {
    drop(Box::from_raw(ladder));
}

/// Adds a new input literal to a [`Ladder`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///     [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `ladder` must be a return value of [`ladder_new`] that [`ladder_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn ladder_add(ladder: *mut Ladder, lit: c_int) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*ladder).extend([lit]);
    MaybeError::Ok
}

/// Builds the [`Ladder`] at-most-one encoding
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Safety
///
/// `ladder` must be a return value of [`ladder_new`] that [`ladder_drop`] has not yet been called on.
#[allow(clippy::missing_panics_doc)]
#[no_mangle]
pub unsafe extern "C" fn ladder_encode(
    ladder: *mut Ladder,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*ladder)
        .encode(&mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Creates a new [`Bitwise`] at-most-one encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn bitwise_new() -> *mut Bitwise {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`Bitwise`]
///
/// # Safety
///
/// `bitwise` must be a return value of [`bitwise_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn bitwise_drop(bitwise: *mut Bitwise) {
    drop(Box::from_raw(bitwise));
}

/// Adds a new input literal to a [`Bitwise`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///     [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `bitwise` must be a return value of [`bitwise_new`] that [`bitwise_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bitwise_add(bitwise: *mut Bitwise, lit: c_int) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*bitwise).extend([lit]);
    MaybeError::Ok
}

/// Builds the [`Bitwise`] at-most-one encoding
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Safety
///
/// `bitwise` must be a return value of [`bitwise_new`] that [`bitwise_drop`] has not yet been called on.
#[allow(clippy::missing_panics_doc)]
#[no_mangle]
pub unsafe extern "C" fn bitwise_encode(
    bitwise: *mut Bitwise,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*bitwise)
        .encode(&mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Creates a new [`Commander`] at-most-one encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn commander_new() -> *mut Commander {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`Commander`]
///
/// # Safety
///
/// `commander` must be a return value of [`commander_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn commander_drop(commander: *mut Commander) {
    drop(Box::from_raw(commander));
}

/// Adds a new input literal to a [`Commander`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///     [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `commander` must be a return value of [`commander_new`] that [`commander_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn commander_add(commander: *mut Commander, lit: c_int) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*commander).0.extend([lit]);
    MaybeError::Ok
}

/// Builds the [`Commander`] at-most-one encoding
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Safety
///
/// `commander` must be a return value of [`commander_new`] that [`commander_drop`] has not yet been called on.
#[allow(clippy::missing_panics_doc)]
#[no_mangle]
pub unsafe extern "C" fn commander_encode(
    commander: *mut Commander,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*commander)
        .0
        .encode(&mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

/// Creates a new [`Bimander`] at-most-one encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn bimander_new() -> *mut Bimander {
    Box::into_raw(Box::default())
}

/// Frees the memory associated with a [`Bimander`]
///
/// # Safety
///
/// `bimander` must be a return value of [`bimander_new`] and cannot be used afterwards again.
#[no_mangle]
pub unsafe extern "C" fn bimander_drop(bimander: *mut Bimander) {
    drop(Box::from_raw(bimander));
}

/// Adds a new input literal to a [`Bimander`] encoding
///
/// # Errors
///
/// - If `lit` is not a valid IPASIR-style literal (e.g., `lit = 0`),
///     [`MaybeError::InvalidLiteral`] is returned
///
/// # Safety
///
/// `bimander` must be a return value of [`bimander_new`] that [`bimander_drop`] has not yet been called on.
#[no_mangle]
pub unsafe extern "C" fn bimander_add(bimander: *mut Bimander, lit: c_int) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*bimander).0.extend([lit]);
    MaybeError::Ok
}

/// Builds the [`Bimander`] at-most-one encoding
///
/// Clauses are returned via the `collector`. The `collector` function should expect clauses to be
/// passed similarly to `ipasir_add`, as a 0-terminated sequence of literals where the literals are
/// passed as the first argument and the `collector_data` as a second.
///
/// `n_vars_used` must be the number of variables already used and will be incremented by the
/// number of variables used up in the encoding.
///
/// # Safety
///
/// `bimander` must be a return value of [`bimander_new`] that [`bimander_drop`] has not yet been called on.
#[allow(clippy::missing_panics_doc)]
#[no_mangle]
pub unsafe extern "C" fn bimander_encode(
    bimander: *mut Bimander,
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*bimander)
        .0
        .encode(&mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}
