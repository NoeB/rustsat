// Auto-generated by codegen, do not edit manually

use std::ffi::{c_int, c_void};

use rustsat::{
    encodings::am1::{Encode,
        {%- for enc in encodings -%}
        {%- if not enc.wrapped -%}{{ enc.name }},{%- endif -%}
        {%- endfor -%}
    },
    types::Lit,
};

use super::{CClauseCollector, ClauseCollector, MaybeError, VarManager,
    {%- for enc in encodings -%}
    {%- if enc.wrapped -%}{{ enc.name }},{%- endif -%}
    {%- endfor -%}
};

{% for enc in encodings %}

/// Creates a new [`{{ enc.name }}`] at-most-one encoding
#[no_mangle]
#[allow(clippy::missing_safety_doc)]
pub unsafe extern "C" fn {{ enc.id }}_new() -> *mut {{ enc.name }} {
    Box::into_raw(Box::default())
}

{% include 'capi-drop.j2' %}

/// Adds a new input literal to a [`{{ enc.name }}`] encoding
///
/// # Errors
///
{% include 'capi-ipasir-lit.j2' %}
{% include 'capi-safety.j2' %}
#[no_mangle]
pub unsafe extern "C" fn {{ enc.id }}_add({{ enc.id }}: *mut {{ enc.name }}, lit: c_int) -> MaybeError {
    let Ok(lit) = Lit::from_ipasir(lit) else {
        return MaybeError::InvalidLiteral;
    };
    (*{{ enc.id }})
        {%- if enc.wrapped -%}.0{%- endif -%}
        .extend([lit]);
    MaybeError::Ok
}

/// Builds the [`{{ enc.name }}`] at-most-one encoding
///
{% include 'capi-collector-n-vars.j2' %}
{% include 'capi-safety.j2' %}
#[allow(clippy::missing_panics_doc)]
#[no_mangle]
pub unsafe extern "C" fn {{ enc.id }}_encode(
    {{ enc.id }}: *mut {{ enc.name }},
    n_vars_used: &mut u32,
    collector: CClauseCollector,
    collector_data: *mut c_void,
) {
    let mut collector = ClauseCollector::new(collector, collector_data);
    let mut var_manager = VarManager::new(n_vars_used);
    (*{{ enc.id }})
        {%- if enc.wrapped -%}.0{%- endif -%}
        .encode(&mut collector, &mut var_manager)
        .expect("CClauseCollector cannot report out of memory");
}

{% endfor %}

#[cfg(all(test, not(target_os = "windows")))]
mod tests {
    use inline_c::assert_c;

    {% for enc in encodings %}

    {% include 'capi-test-drop.j2' %}

    #[test]
    fn {{ enc.id }}_basic() {
        (assert_c! {
            #include <assert.h>
            #include "rustsat.h"

            void clause_counter(int lit, void *data) {
                if (!lit) {
                    int *cnt = (int *)data;
                    (*cnt)++;
                }
            }

            int main() {
                {{ enc.name }} *{{ enc.id }} = {{ enc.id }}_new();
                assert({{ enc.id }}_add({{ enc.id }}, 1) == Ok);
                assert({{ enc.id }}_add({{ enc.id }}, 2) == Ok);
                assert({{ enc.id }}_add({{ enc.id }}, 3) == Ok);
                assert({{ enc.id }}_add({{ enc.id }}, 4) == Ok);
                uint32_t n_used = 4;
                uint32_t n_clauses = 0;
                {{ enc.id }}_encode({{ enc.id }}, &n_used, &clause_counter, &n_clauses);
                {{ enc.id }}_drop({{ enc.id }});
                assert(n_used == {{ enc.n_vars }});
                assert(n_clauses == {{ enc.n_clauses }});
                return 0;
            }
        })
        .success();
    }

    {% endfor %}
}
